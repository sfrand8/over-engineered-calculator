// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package calculate

import (
	"over-engineered-calculator/internal/database"
	"sync"
)

// Ensure, that calculatorMock does implement calculator.
// If this is not the case, regenerate this file with moq.
var _ calculator = &calculatorMock{}

// calculatorMock is a mock implementation of calculator.
//
//	func TestSomethingThatUsescalculator(t *testing.T) {
//
//		// make and configure a mocked calculator
//		mockedcalculator := &calculatorMock{
//			PerformCalculationForUserFunc: func(userID string, expressionString string) (database.Calculation, error) {
//				panic("mock out the PerformCalculationForUser method")
//			},
//		}
//
//		// use mockedcalculator in code that requires calculator
//		// and then make assertions.
//
//	}
type calculatorMock struct {
	// PerformCalculationForUserFunc mocks the PerformCalculationForUser method.
	PerformCalculationForUserFunc func(userID string, expressionString string) (database.Calculation, error)

	// calls tracks calls to the methods.
	calls struct {
		// PerformCalculationForUser holds details about calls to the PerformCalculationForUser method.
		PerformCalculationForUser []struct {
			// UserID is the userID argument value.
			UserID string
			// ExpressionString is the expressionString argument value.
			ExpressionString string
		}
	}
	lockPerformCalculationForUser sync.RWMutex
}

// PerformCalculationForUser calls PerformCalculationForUserFunc.
func (mock *calculatorMock) PerformCalculationForUser(userID string, expressionString string) (database.Calculation, error) {
	if mock.PerformCalculationForUserFunc == nil {
		panic("calculatorMock.PerformCalculationForUserFunc: method is nil but calculator.PerformCalculationForUser was just called")
	}
	callInfo := struct {
		UserID           string
		ExpressionString string
	}{
		UserID:           userID,
		ExpressionString: expressionString,
	}
	mock.lockPerformCalculationForUser.Lock()
	mock.calls.PerformCalculationForUser = append(mock.calls.PerformCalculationForUser, callInfo)
	mock.lockPerformCalculationForUser.Unlock()
	return mock.PerformCalculationForUserFunc(userID, expressionString)
}

// PerformCalculationForUserCalls gets all the calls that were made to PerformCalculationForUser.
// Check the length with:
//
//	len(mockedcalculator.PerformCalculationForUserCalls())
func (mock *calculatorMock) PerformCalculationForUserCalls() []struct {
	UserID           string
	ExpressionString string
} {
	var calls []struct {
		UserID           string
		ExpressionString string
	}
	mock.lockPerformCalculationForUser.RLock()
	calls = mock.calls.PerformCalculationForUser
	mock.lockPerformCalculationForUser.RUnlock()
	return calls
}

// Ensure, that calculationHistorySaverMock does implement calculationHistorySaver.
// If this is not the case, regenerate this file with moq.
var _ calculationHistorySaver = &calculationHistorySaverMock{}

// calculationHistorySaverMock is a mock implementation of calculationHistorySaver.
//
//	func TestSomethingThatUsescalculationHistorySaver(t *testing.T) {
//
//		// make and configure a mocked calculationHistorySaver
//		mockedcalculationHistorySaver := &calculationHistorySaverMock{
//			SaveFunc: func(userID string, calculation database.Calculation) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedcalculationHistorySaver in code that requires calculationHistorySaver
//		// and then make assertions.
//
//	}
type calculationHistorySaverMock struct {
	// SaveFunc mocks the Save method.
	SaveFunc func(userID string, calculation database.Calculation) error

	// calls tracks calls to the methods.
	calls struct {
		// Save holds details about calls to the Save method.
		Save []struct {
			// UserID is the userID argument value.
			UserID string
			// Calculation is the calculation argument value.
			Calculation database.Calculation
		}
	}
	lockSave sync.RWMutex
}

// Save calls SaveFunc.
func (mock *calculationHistorySaverMock) Save(userID string, calculation database.Calculation) error {
	if mock.SaveFunc == nil {
		panic("calculationHistorySaverMock.SaveFunc: method is nil but calculationHistorySaver.Save was just called")
	}
	callInfo := struct {
		UserID      string
		Calculation database.Calculation
	}{
		UserID:      userID,
		Calculation: calculation,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(userID, calculation)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedcalculationHistorySaver.SaveCalls())
func (mock *calculationHistorySaverMock) SaveCalls() []struct {
	UserID      string
	Calculation database.Calculation
} {
	var calls []struct {
		UserID      string
		Calculation database.Calculation
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure, that expressionEvaluatorMock does implement expressionEvaluator.
// If this is not the case, regenerate this file with moq.
var _ expressionEvaluator = &expressionEvaluatorMock{}

// expressionEvaluatorMock is a mock implementation of expressionEvaluator.
//
//	func TestSomethingThatUsesexpressionEvaluator(t *testing.T) {
//
//		// make and configure a mocked expressionEvaluator
//		mockedexpressionEvaluator := &expressionEvaluatorMock{
//			EvaluateFunc: func(expressionString string) (interface{}, error) {
//				panic("mock out the Evaluate method")
//			},
//		}
//
//		// use mockedexpressionEvaluator in code that requires expressionEvaluator
//		// and then make assertions.
//
//	}
type expressionEvaluatorMock struct {
	// EvaluateFunc mocks the Evaluate method.
	EvaluateFunc func(expressionString string) (interface{}, error)

	// calls tracks calls to the methods.
	calls struct {
		// Evaluate holds details about calls to the Evaluate method.
		Evaluate []struct {
			// ExpressionString is the expressionString argument value.
			ExpressionString string
		}
	}
	lockEvaluate sync.RWMutex
}

// Evaluate calls EvaluateFunc.
func (mock *expressionEvaluatorMock) Evaluate(expressionString string) (interface{}, error) {
	if mock.EvaluateFunc == nil {
		panic("expressionEvaluatorMock.EvaluateFunc: method is nil but expressionEvaluator.Evaluate was just called")
	}
	callInfo := struct {
		ExpressionString string
	}{
		ExpressionString: expressionString,
	}
	mock.lockEvaluate.Lock()
	mock.calls.Evaluate = append(mock.calls.Evaluate, callInfo)
	mock.lockEvaluate.Unlock()
	return mock.EvaluateFunc(expressionString)
}

// EvaluateCalls gets all the calls that were made to Evaluate.
// Check the length with:
//
//	len(mockedexpressionEvaluator.EvaluateCalls())
func (mock *expressionEvaluatorMock) EvaluateCalls() []struct {
	ExpressionString string
} {
	var calls []struct {
		ExpressionString string
	}
	mock.lockEvaluate.RLock()
	calls = mock.calls.Evaluate
	mock.lockEvaluate.RUnlock()
	return calls
}
